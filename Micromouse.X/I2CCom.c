
#include <p33FJ128MC802.h>
#include "IOconfig.h"


// default address of distance sensor 0x29
// I2CxRCV is the receive buffer
// I2CxADD register holds the slave address
#define SLAVEADDRESS 0x29
#define I2CSTAT_BIT_MASK  0b00100100


// S = 1, D_A = 0, R_W = 0   
#define state_1 0b00000000
//  S = 1, D_A = 0, R_W = 1   
#define state_2 0b00000100
// S = 1, D_A = 1, R_W = 1	  Master Read => Slave send data
#define state_3 0b00100100
// S = 1, D_A = 1, R_W = 0   Master Write => Slave receive data
#define state_4 0b00100000


void setupI2C()
{
    // Disable i2C module before initialization
    I2C1CONbits.I2CEN = 0;
    
    // Configure SDA/SCL pins as open-drain pins
    ODCBbits.ODCB8 = 1;
    ODCBbits.ODCB9 = 1;
    
    IEC1bits.MI2C1IE = 1;
    // Enter slave address
    I2CADD = SLAVEADDRESS;
    
    // Our slave has a 7-bit address (0x29))
    I2C1CONbits.A10M = 0;
    
    // set baudrate --> range sensor uses 400kHz
    I2C1BRG = 0x29;
    I2C1CONbits.IPMIEN = 0;
    
   
    // Enable it + configure SDA /SCL pins
    I2C1CONbits.I2CEN = 0;
}

// Register with range result: 0x062
void readI2C()
{
    // Start condition detected 
    if(I2C1STATbits.P == 1)    
    {
        I2C1CONbits.SEN = 1;
    }
    
    // without interrupt:
    char dev_addr = 0x29;
    char wr_dev_addr = dev_addr << 1;
    char rd_dev_addr = (dev_addr << 1) | 0x01;
    
    while(I2CCONbits.SEN == 1);
    
    I2C1TRN = 0x52;
    
    if (I2C1STATbits.ACKSTAT)
	{
		I2C1CONbits.PEN = 1;
		while(I2C1CONbits.PEN);
		return -1;
	}
    // Send I2C register address on the bus 
	I2CTRN = 0x00;
	while(I2CSTATbits.TRSTAT);
	if (I2CSTATbits.ACKSTAT)
	{	
		I2CCONbits.PEN = 1;
		while(I2CCONbits.PEN);
		return -1;
	}
    I2CTRN = 0x62;
	while(I2CSTATbits.TRSTAT);
	if (I2CSTATbits.ACKSTAT)
	{	
		I2CCONbits.PEN = 1;
		while(I2CCONbits.PEN);
		return -1;
	}
    
    I2C1CONbits.RSEN = 1;
    while(I2C1CONbits.RSEN == 1);	
    
    // Send I2C device address on the bus for read operation
    I2C1TRN = 0x53;
	while(I2C1STATbits.TRSTAT);
    
	if (I2C1STATbits.ACKSTAT)
	{
		I2C1CONbits.PEN = 1;
		while(I2C1CONbits.PEN);
		return -1;	
	}
    
    // Enable I2C clock for read operation
	I2C1CONbits.RCEN = 1;
    LATBbits.LATB13 = 1;
    while(I2C1STATbits.RBF == 0);
    
    // Retrieve value from I2C register
    char value;
	value = I2C1RCV;	
	// Send I2C stop condition
	I2C1CONbits.PEN = 1;
	while(I2C1CONbits.PEN);
	return 0;
    
}

// Interrupt generated by master on the following events: start - stop - data transfer - ack
void __attribute__((interrupt, no_auto_psv)) _MI2C1Interrupt(void) 
{
    // clear interrupt enable bit
    IFS1bits.MI2C1IF = 0;	
       
    reactOnI2CStatus();
}

// Check reason for interrupt + react accordingly
void reactOnI2CStatus()
{
    if(I2C1STATbits.S == 1)    // Start condition detected 
    {
        
        I2C1TRN = (SLAVEADDRESS << 1) + 0; // write address
         
    }
    else if(I2C1STATbits.ACKSTAT == 0 && ((I2C1CON & 0x1F) ^ 0b11111111)) // ACK from slave received and last 5 bits of I2C1CON are zero
    {
        
        I2C1CONbits.RSEN = 1;
        I2C1TRN = (SLAVEADDRESS << 1) + 1;
        LATBbits.LATB13 = 1;
    }
    else if((I2C1STATbits.RBF == 1)) // Data received
    {
        int temp = I2C1RCV;
        I2C1CONbits.ACKEN = 1;
        
    }
    else if (I2C1STATbits.ACKSTAT)
    {
        I2C1CONbits.ACKEN = 1;
    }
}